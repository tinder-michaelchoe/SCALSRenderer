# Snapshot Testing Implementation Plan for ScalsRenderer

## Executive Summary

This plan outlines a comprehensive snapshot testing strategy for the ScalsRenderer project to verify cross-renderer consistency and prevent visual regressions. The system will test that SwiftUI, UIKit, and HTML renderers produce equivalent outputs from the same IR (Intermediate Representation), and compare against canonical reference implementations.

### ü§ñ Autonomous Execution

**This test suite is designed for fully autonomous operation.** Once initiated, the implementation process runs continuously without human intervention:

- ‚úÖ Tests are written, run, and verified automatically
- ‚úÖ Tolerance values are adjusted autonomously when needed
- ‚úÖ Renderer and SCALS bugs are fixed as discovered
- ‚úÖ Passing tests are committed automatically
- ‚úÖ Failing tests are documented and skipped after reasonable attempts
- ‚úÖ Progress is tracked in `SNAPSHOT_TEST_PROGRESS.md`
- ‚ùå **No approval requests** - runs until all test cases are complete

**Monitoring**: Track progress via git commits, `SNAPSHOT_TEST_PROGRESS.md`, and `FAILING_TESTS.md`

**Branching Strategy**: Each phase runs on its own branch with savepoint tags for easy rollback

## 1. Goals

### Primary Goals
1. **Cross-Renderer Consistency**: Verify that SwiftUI, UIKit, and HTML renderers produce equivalent visual output for identical IR
2. **Regression Prevention**: Catch visual regressions when renderer implementations change
3. **Canonical Compliance**: Compare renderer outputs against canonical SwiftUI/UIKit implementations
4. **Example Coverage**: Validate all 48 example files render correctly

### Success Metrics
- 100% of RenderNode types tested
- <3% visual difference between SwiftUI/UIKit for identical IR
- Catch visual regressions within 1 pixel tolerance
- Tier 1 tests complete in <2 minutes
- CI integration on every PR

## 2. Architecture Overview

### 2.1 Test Organization

```
ScalsModulesTests/
‚îú‚îÄ‚îÄ SnapshotTests/
‚îÇ   ‚îú‚îÄ‚îÄ Components/              # Individual component snapshots
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TextNodeSnapshotTests.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ButtonNodeSnapshotTests.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ImageNodeSnapshotTests.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ Layouts/                 # Layout component snapshots
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ VStackSnapshotTests.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ HStackSnapshotTests.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ListSnapshotTests.swift
‚îÇ   ‚îú‚îÄ‚îÄ CrossRenderer/           # Consistency tests
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ComponentConsistencyTests.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LayoutConsistencyTests.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ StateBindingConsistencyTests.swift
‚îÇ   ‚îú‚îÄ‚îÄ Examples/                # Example-based tests
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ComponentExamplesSnapshotTests.swift
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LayoutExamplesSnapshotTests.swift
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ComplexExamplesSnapshotTests.swift
‚îÇ   ‚îú‚îÄ‚îÄ Canonical/               # Canonical comparison tests
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CanonicalComparisonTests.swift
‚îÇ   ‚îî‚îÄ‚îÄ Helpers/                 # Test infrastructure
‚îÇ       ‚îú‚îÄ‚îÄ SnapshotTestHelpers.swift
‚îÇ       ‚îú‚îÄ‚îÄ RendererTestHelpers.swift
‚îÇ       ‚îú‚îÄ‚îÄ StandardSnapshotSizes.swift
‚îÇ       ‚îú‚îÄ‚îÄ ExampleDataLoader.swift
‚îÇ       ‚îî‚îÄ‚îÄ RendererComparisonHelper.swift
‚îî‚îÄ‚îÄ __Snapshots__/               # Generated by swift-snapshot-testing
    ‚îú‚îÄ‚îÄ Components/
    ‚îú‚îÄ‚îÄ Layouts/
    ‚îú‚îÄ‚îÄ CrossRenderer/
    ‚îú‚îÄ‚îÄ Examples/
    ‚îî‚îÄ‚îÄ Canonical/
```

### 2.2 Snapshot Naming Convention

```
{renderer}-{category}-{component}-{variant}-{size}.png

Examples:
- swiftui-components-text-light-375x100.png
- uikit-layouts-vstack-dark-375x667.png
- html-components-button-hover-414x100.png
- consistency-text-swiftui-vs-uikit-375x100.png
```

### 2.3 Test Tiers

With XCTest, organize tests using class naming and explicit test selection:

**Tier 1: Smoke Tests** (Run on every commit, ~2 min)
- 10 core components (text, button, image, vstack, hstack, zstack, list, scrollview, spacer, divider)
- SwiftUI and UIKit renderers only
- Light mode, standard sizes
- Test classes: `TextNodeSnapshotTests`, `ButtonNodeSnapshotTests`, etc.
- Run with: `xcodebuild test -only-testing:ScalsModulesTests/TextNodeSnapshotTests ...`

**Tier 2: Component Coverage** (Run on PR, ~5 min)
- All 25+ component types
- SwiftUI, UIKit, HTML renderers
- Light and dark mode
- Standard sizes
- All `*SnapshotTests` test classes
- Run with: `xcodebuild test -scheme ScalsRenderer`

**Tier 3: Cross-Renderer Consistency** (Run nightly, ~10 min)
- All components with side-by-side comparison
- Structural equivalence validation
- Tolerance-based image comparison
- Test classes: `*ConsistencyTests`
- Run with: `xcodebuild test -only-testing:ScalsModulesTests/ComponentConsistencyTests`

**Tier 4: Full Integration** (Run weekly, ~30 min)
- All 48 examples
- All renderers
- Multiple content sizes (compact, standard, medium, large, fullscreen)
- Accessibility variants (dynamic type, high contrast)
- State change sequences
- Test classes: `*ExamplesSnapshotTests`, `*CanonicalTests`
- Run all tests

## 3. Implementation Components

### 3.1 Core Helper Infrastructure

#### StandardSnapshotSizes.swift
```swift
import CoreGraphics

struct StandardSnapshotSizes {
    // Device size - using iPhone 13 for all snapshots
    static let iPhone13 = CGSize(width: 390, height: 844)
    static let iPhone13ScreenWidth: CGFloat = 390

    // Common component sizes (width x height)
    // All use iPhone 13 width for consistency
    static let compact = CGSize(width: 390, height: 100)    // Single line items (text, simple buttons)
    static let standard = CGSize(width: 390, height: 200)   // Cards, buttons with padding
    static let medium = CGSize(width: 390, height: 400)     // Forms, lists with multiple items
    static let large = CGSize(width: 390, height: 600)      // Scrollable content, complex layouts
    static let fullscreen = CGSize(width: 390, height: 844) // Full screen views

    // Helper to create custom size with iPhone 13 width
    static func custom(height: CGFloat) -> CGSize {
        CGSize(width: iPhone13ScreenWidth, height: height)
    }

    // Helper to get appropriate size for example files
    // Analyzes example content to determine best size
    static func sizeForExample(_ example: Example) -> CGSize {
        // Use example metadata or content analysis to choose size
        // Default to standard for most examples
        return standard
    }
}
```

**Usage Examples:**
```swift
// Use preset sizes based on content
let textImage = await RendererTestHelpers.renderSwiftUI(
    textNode,
    size: StandardSnapshotSizes.compact  // 390x100 for simple text
)

let buttonImage = await RendererTestHelpers.renderSwiftUI(
    buttonNode,
    size: StandardSnapshotSizes.standard  // 390x200 for buttons
)

let listImage = await RendererTestHelpers.renderSwiftUI(
    listNode,
    size: StandardSnapshotSizes.large  // 390x600 for lists
)

// Use custom height when needed
let customImage = await RendererTestHelpers.renderSwiftUI(
    node,
    size: StandardSnapshotSizes.custom(height: 350)  // 390x350
)

// Or completely custom size
let specialImage = await RendererTestHelpers.renderSwiftUI(
    node,
    size: CGSize(width: 390, height: 275)
)
```

**Benefits:**
- No maintenance burden - add components without updating enums
- Flexible - tests choose appropriate size based on actual content
- Simple - just constants, no complex lookup logic
- Consistent - all use iPhone 13 width (390pt)
- Clear - size intent is obvious from constant names

#### RendererTestHelpers.swift
```swift
struct RendererTestHelpers {
    // Render a node using SwiftUI
    @MainActor
    static func renderSwiftUI(
        _ node: RenderNode,
        size: CGSize,
        traits: UITraitCollection = .default
    ) async -> UIImage

    // Render a node using UIKit
    @MainActor
    static func renderUIKit(
        _ node: RenderNode,
        size: CGSize,
        traits: UITraitCollection = .default
    ) async -> UIImage

    // Render a node using HTML (via WKWebView)
    @MainActor
    static func renderHTML(
        _ node: RenderNode,
        size: CGSize
    ) async throws -> UIImage

    // Render a full tree with SwiftUI
    @MainActor
    static func renderSwiftUITree(
        _ tree: RenderTree,
        size: CGSize,
        traits: UITraitCollection = .default
    ) async -> UIImage

    // Render a full tree with UIKit
    @MainActor
    static func renderUIKitTree(
        _ tree: RenderTree,
        size: CGSize,
        traits: UITraitCollection = .default
    ) async -> UIImage

    // Render a full tree with HTML
    @MainActor
    static func renderHTMLTree(
        _ tree: RenderTree,
        size: CGSize
    ) async throws -> UIImage

    // Render a canonical SwiftUI view (passed inline with @ViewBuilder)
    @MainActor
    static func renderCanonicalView<Content: View>(
        @ViewBuilder _ content: () -> Content,
        size: CGSize,
        traits: UITraitCollection = .default
    ) async -> UIImage
}
```

#### SnapshotTestHelpers.swift
```swift
// No complex naming helpers needed - tests use simple string names directly

// Example snapshot names:
// "text-basic"
// "text-light"
// "text-dark"
// "button-normal"
// "button-disabled"
// "consistency/text-swiftui-vs-uikit"
// "canonical/text-scals"
// "examples/01_text_basic-swiftui"
```

**Naming Convention Guidelines:**
- Component tests: `"{component}-{variant}"` (e.g., `"text-basic"`, `"button-disabled"`)
- Color scheme tests: `"{component}-{colorScheme}"` (e.g., `"text-light"`, `"text-dark"`)
- Cross-renderer tests: `"consistency/{component}-{renderer}"` (e.g., `"consistency/text-swiftui"`)
- Canonical tests: `"canonical/{component}-{type}"` (e.g., `"canonical/text-scals"`, `"canonical/text-swiftui"`)
- Example tests: `"examples/{exampleName}-{renderer}"` (e.g., `"examples/01_text_basic-swiftui"`)

#### RendererComparisonHelper.swift
```swift
struct RendererComparisonHelper {
    // Compare two images with tolerance
    static func assertStructuralEquivalence(
        _ image1: UIImage,
        _ image2: UIImage,
        tolerance: Float,
        named: String
    ) throws

    // Generate diff image highlighting differences
    static func generateDiffImage(
        _ reference: UIImage,
        _ actual: UIImage
    ) -> UIImage

    // Calculate perceptual difference score
    static func calculatePerceptualDifference(
        _ image1: UIImage,
        _ image2: UIImage
    ) -> Float
}
```

#### ExampleDataLoader.swift
```swift
struct ExampleDataLoader {
    // Load a specific example file
    static func loadExample(_ example: Example) throws -> RenderTree

    // Get all examples
    static func allExamples() -> [Example] {
        return Example.allCases
    }

    // Predefined example subsets for different test classes
    static let smokeTestExamples: [Example] = [
        .textBasic,
        .buttonActions,
        .imageDisplay,
        .vStackLayout,
        .hStackLayout,
        .listBasic,
        .formSimple,
        .stateBinding,
        .actionHandling,
        .conditionalRendering
    ]

    static let layoutExamples: [Example] = [
        .vStackLayout,
        .hStackLayout,
        .zStackLayout,
        .gridLayout,
        .listBasic,
        .listSections,
        // ... layout examples
    ]

    static let complexExamples: [Example] = [
        .nestedLayouts,
        .dynamicContent,
        .stateManagement,
        // ... complex examples
    ]
}

enum Example: String, CaseIterable {
    // Component examples (10 examples)
    case textBasic = "01_text_basic"
    case buttonActions = "02_button_actions"
    case imageDisplay = "03_image_display"
    case inputField = "04_input_field"
    case toggleSwitch = "05_toggle_switch"

    // Layout examples (15 examples)
    case vStackLayout = "10_vstack_layout"
    case hStackLayout = "11_hstack_layout"
    case zStackLayout = "12_zstack_layout"
    case gridLayout = "13_grid_layout"
    case listBasic = "14_list_basic"
    case listSections = "15_list_sections"

    // State & Actions (10 examples)
    case stateBinding = "20_state_binding"
    case actionHandling = "21_action_handling"
    case conditionalRendering = "22_conditional_rendering"

    // Complex scenarios (13 examples)
    case nestedLayouts = "30_nested_layouts"
    case dynamicContent = "31_dynamic_content"
    case stateManagement = "32_state_management"

    // ... 45 more examples total
}
```

**Organization Strategy:**
- Different test classes use different example subsets
- No need for tier enums - just organize by test class
- Run specific test classes to control which examples are tested

### 3.2 Example Test Implementations

#### TextNodeSnapshotTests.swift
```swift
import XCTest
import SnapshotTesting
import SCALS
import ScalsModules

final class TextNodeSnapshotTests: XCTestCase {

    @MainActor
    func testTextWithBasicStyle() async throws {
        let node = RenderNode.text(TextNode(
            content: "Hello World",
            style: IR.Style(fontSize: 16, textColor: .black),
            padding: .zero
        ))

        let image = await RendererTestHelpers.renderSwiftUI(
            node,
            size: StandardSnapshotSizes.compact  // Simple text fits in compact size
        )

        assertSnapshot(
            of: image,
            as: .image,
            named: "text-basic"
        )
    }

    @MainActor
    func testTextWithColorSchemes() async throws {
        let testCases: [(name: String, style: UIUserInterfaceStyle)] = [
            ("Light", .light),
            ("Dark", .dark)
        ]

        for (name, style) in testCases {
            let node = RenderNode.text(TextNode(
                content: "Color Scheme Test",
                style: IR.Style(fontSize: 16),
                padding: .zero
            ))

            let traits = UITraitCollection(userInterfaceStyle: style)
            let image = await RendererTestHelpers.renderSwiftUI(
                node,
                size: StandardSnapshotSizes.compact,
                traits: traits
            )

            assertSnapshot(
                of: image,
                as: .image,
                named: "text-colorScheme-\(name.lowercased())"
            )
        }
    }

    @MainActor
    func testTextWithMultipleStyles() async throws {
        // Test font weights, sizes, colors, alignment
    }

    @MainActor
    func testTextWithBinding() async throws {
        // Test dynamic text binding to state
    }
}
```

#### ComponentConsistencyTests.swift
```swift
import XCTest
import SnapshotTesting
import SCALS
import ScalsModules

final class ComponentConsistencyTests: XCTestCase {

    @MainActor
    func testTextNodeConsistency() async throws {
        let node = RenderNode.text(TextNode(
            content: "Consistency Test",
            style: IR.Style(fontSize: 16, textColor: .black),
            padding: .zero
        ))

        let size = CGSize(width: 375, height: 100)

        // Render with all renderers
        let swiftUIImage = await RendererTestHelpers.renderSwiftUI(node, size: size)
        let uikitImage = await RendererTestHelpers.renderUIKit(node, size: size)
        let htmlImage = try await RendererTestHelpers.renderHTML(node, size: size)

        // Save all snapshots for visual comparison
        assertSnapshot(of: swiftUIImage, as: .image, named: "consistency/text-swiftui")
        assertSnapshot(of: uikitImage, as: .image, named: "consistency/text-uikit")
        assertSnapshot(of: htmlImage, as: .image, named: "consistency/text-html")

        // Verify structural similarity
        try RendererComparisonHelper.assertStructuralEquivalence(
            swiftUIImage,
            uikitImage,
            tolerance: 0.03,
            named: "text-swiftui-vs-uikit"
        )
    }

    @MainActor
    func testButtonNodeConsistency() async throws {
        // Similar pattern for buttons
    }

    @MainActor
    func testAllComponentsConsistency() async throws {
        // Test all node types
        for nodeKind in RenderNodeKind.allCases {
            // Create appropriate node for nodeKind and test consistency
        }
    }
}
```

#### SmokeTestExamplesSnapshotTests.swift
```swift
import XCTest
import SnapshotTesting
import SCALS
import ScalsModules

/// Tier 1: Quick smoke tests for core examples (run on every commit)
final class SmokeTestExamplesSnapshotTests: XCTestCase {

    @MainActor
    func testSmokeTestExamples() async throws {
        // Test a small subset of critical examples
        for example in ExampleDataLoader.smokeTestExamples {
            let tree = try ExampleDataLoader.loadExample(example)
            let size = StandardSnapshotSizes.sizeForExample(example)

            let image = await RendererTestHelpers.renderSwiftUITree(tree, size: size)

            assertSnapshot(
                of: image,
                as: .image,
                named: "examples/\(example.rawValue)-swiftui"
            )
        }
    }
}
```

#### FullExampleCoverageSnapshotTests.swift
```swift
import XCTest
import SnapshotTesting
import SCALS
import ScalsModules

/// Tier 4: Full example coverage (run weekly)
final class FullExampleCoverageSnapshotTests: XCTestCase {

    @MainActor
    func testAllExamplesSwiftUI() async throws {
        for example in ExampleDataLoader.allExamples() {
            let tree = try ExampleDataLoader.loadExample(example)
            let size = StandardSnapshotSizes.sizeForExample(example)

            let image = await RendererTestHelpers.renderSwiftUITree(tree, size: size)

            assertSnapshot(
                of: image,
                as: .image,
                named: "examples/\(example.rawValue)-swiftui"
            )
        }
    }

    @MainActor
    func testAllExamplesUIKit() async throws {
        for example in ExampleDataLoader.allExamples() {
            let tree = try ExampleDataLoader.loadExample(example)
            let size = StandardSnapshotSizes.sizeForExample(example)

            let image = await RendererTestHelpers.renderUIKitTree(tree, size: size)

            assertSnapshot(
                of: image,
                as: .image,
                named: "examples/\(example.rawValue)-uikit"
            )
        }
    }

    @MainActor
    func testAllExamplesHTML() async throws {
        for example in ExampleDataLoader.allExamples() {
            let tree = try ExampleDataLoader.loadExample(example)
            let size = StandardSnapshotSizes.sizeForExample(example)

            let image = try await RendererTestHelpers.renderHTMLTree(tree, size: size)

            assertSnapshot(
                of: image,
                as: .image,
                named: "examples/\(example.rawValue)-html"
            )
        }
    }
}
```

#### CanonicalComparisonTests.swift
```swift
import XCTest
import SwiftUI
import SnapshotTesting
import SCALS
import ScalsModules

final class CanonicalComparisonTests: XCTestCase {

    @MainActor
    func testTextNodeVsCanonicalSwiftUI() async throws {
        // Create equivalent IR node
        let node = RenderNode.text(TextNode(
            content: "Canonical Test",
            style: IR.Style(fontSize: 16, textColor: .black),
            padding: .zero
        ))

        // Render with ScalsRenderer
        let scalsImage = await RendererTestHelpers.renderSwiftUI(
            node,
            size: StandardSnapshotSizes.compact
        )

        // Render with canonical SwiftUI (inline @ViewBuilder)
        let canonicalImage = await RendererTestHelpers.renderCanonicalView(
            size: StandardSnapshotSizes.compact
        ) {
            Text("Canonical Test")
                .font(.system(size: 16))
                .foregroundColor(.black)
        }

        // Compare
        assertSnapshot(of: scalsImage, as: .image, named: "canonical/text-scals")
        assertSnapshot(of: canonicalImage, as: .image, named: "canonical/text-swiftui")

        try RendererComparisonHelper.assertStructuralEquivalence(
            scalsImage,
            canonicalImage,
            tolerance: 0.05,
            named: "text-scals-vs-canonical"
        )
    }
}
```

### 3.3 Canonical Reference Implementations

Canonical comparisons validate that SCALS renderers produce output equivalent to pure SwiftUI/UIKit implementations. Instead of creating separate helper classes, canonical views are created inline using `@ViewBuilder` for clarity.

#### SwiftUI Canonical Views
Use `RendererTestHelpers.renderCanonicalView` with inline SwiftUI:

```swift
// Render canonical SwiftUI text
let canonicalImage = await RendererTestHelpers.renderCanonicalView(size: size) {
    Text("Hello World")
        .font(.system(size: 16))
        .foregroundColor(.black)
}

// Render canonical SwiftUI button
let canonicalImage = await RendererTestHelpers.renderCanonicalView(size: size) {
    Button(action: {}) {
        Text("Tap Me")
    }
}

// Render canonical SwiftUI VStack
let canonicalImage = await RendererTestHelpers.renderCanonicalView(size: size) {
    VStack(spacing: 8) {
        Text("First")
        Text("Second")
    }
}
```

#### UIKit Canonical Views
Create UIKit views inline in tests:

```swift
// Render canonical UIKit text
let label = UILabel()
label.text = "Hello World"
label.font = .systemFont(ofSize: 16)
label.textColor = .black
let canonicalImage = await RendererTestHelpers.renderUIKitView(label, size: size)

// Render canonical UIKit button
let button = UIButton(type: .system)
button.setTitle("Tap Me", for: .normal)
let canonicalImage = await RendererTestHelpers.renderUIKitView(button, size: size)
```

**Benefits of Inline Approach:**
- Test readers see exact canonical implementation without navigating to other files
- Easier to spot differences between SCALS and canonical versions
- No need to maintain separate canonical view library
- Reduces indirection and improves test clarity

## 4. Testing Strategy by Renderer

### 4.1 SwiftUI Renderer Testing
- **Strategy**: Use `.image` snapshots with UITraitCollection for light/dark mode
- **Sizes**: All tests use iPhone 13 width (390pt) with varying heights based on content
- **Variants**: Light mode, dark mode, dynamic type sizes
- **Challenges**: SwiftUI rendering timing, preview vs runtime differences
- **Solution**: Use `@MainActor` and proper async/await for consistent rendering

### 4.2 UIKit Renderer Testing
- **Strategy**: Render UIViews to images using UIGraphicsImageRenderer
- **Sizes**: Same as SwiftUI (iPhone 13 width: 390pt) for direct comparison
- **Variants**: Light/dark via UITraitCollection, accessibility sizes
- **Challenges**: Layout timing, auto-layout resolution
- **Solution**: Force layout pass before rendering, use fixed constraints

### 4.3 HTML Renderer Testing
- **Strategy**: Render HTML in WKWebView, capture as image
- **UI Framework**: Use [Konsta UI](https://github.com/konstaui/konsta) to mimic iOS native look
  - Konsta UI provides iOS-styled components in HTML/CSS (buttons, lists, forms, etc.)
  - Helps achieve visual parity with SwiftUI/UIKit renderers
  - Makes cross-renderer consistency tests more meaningful
- **Sizes**: Viewport width set to iPhone 13 (390pt) for consistency with native renderers
- **Variants**: CSS media queries for responsive design, iOS light/dark themes via Konsta
- **Challenges**: Async rendering, font loading, WebKit-specific rendering, CSS framework integration
- **Solution**:
  - Use actor-based HTMLSnapshotRenderer with proper timing delays
  - Load Konsta UI CSS in HTML output
  - Use Konsta's iOS theme classes for component styling

## 5. Key Pitfalls and Solutions

### 5.1 Rendering Timing Issues
**Pitfall**: SwiftUI/UIKit views not fully rendered before snapshot
**Solution**:
- Use `@MainActor` for all snapshot tests
- Force layout passes with `layoutIfNeeded()` for UIKit
- Use Task delays or observation for SwiftUI

### 5.2 Font Rendering Differences
**Pitfall**: System fonts render differently across iOS versions and simulators
**Solution**:
- Pin specific font names rather than system fonts
- Use SF Pro fonts explicitly
- Document expected iOS version in snapshots

### 5.3 Image Color Space Differences
**Pitfall**: Different color spaces cause false failures
**Solution**:
- Normalize all images to sRGB before comparison
- Use perceptual precision in SnapshotTesting config
- Set tolerance thresholds (0.01-0.03)

### 5.4 Size Calculation Inconsistencies
**Pitfall**: SwiftUI's `.frame()` vs UIKit's frame setting differ
**Solution**:
- Use explicit sizing for all test renders
- Create StandardSnapshotSizes for consistency
- Document expected sizes in test names

### 5.5 State Management in Tests
**Pitfall**: State changes during rendering cause flakiness
**Solution**:
- Use MockStateStore with pre-populated values
- Avoid actual state mutations during snapshot capture
- Test state changes as separate before/after snapshots

### 5.6 HTML Rendering Delays
**Pitfall**: WKWebView renders asynchronously, snapshots too early
**Solution**:
- Wait for document.readyState === 'complete'
- Add additional 200-500ms delay for font loading
- Use actor isolation to prevent race conditions

### 5.7 CI/CD Environment Differences
**Pitfall**: Snapshots differ between local and CI simulators
**Solution**:
- Pin Xcode version in CI
- Use consistent simulator OS versions
- Run tests on same simulator device type
- Consider recording mode for CI updates

### 5.8 Test Suite Performance
**Pitfall**: 48 examples √ó 3 renderers √ó 2 modes = 288+ snapshots
**Solution**:
- Implement test tiers (smoke, PR, nightly, weekly)
- Use `-only-testing` to run specific test classes
- Parallelize test execution with `xcodebuild test -parallel-testing-enabled YES`
- Organize tests into separate test classes for granular execution
- Cache rendered results within test session

### 5.9 Snapshot Management
**Pitfall**: Large binary snapshot files bloat git repository
**Solution**:
- Use Git LFS for `__Snapshots__/` directory
- Implement snapshot cleanup scripts
- Review snapshot changes in PRs carefully
- Consider separate snapshot repo for large projects

### 5.10 Cross-Renderer Tolerance
**Pitfall**: SwiftUI, UIKit, and HTML render slightly differently (anti-aliasing, spacing, font rendering)
**Solution**:
- **Native renderers** (SwiftUI vs UIKit): Use tolerance 0.02-0.03 for minor anti-aliasing differences
- **HTML renderer**: With Konsta UI, aim for tolerance 0.05-0.08 due to web font rendering differences
- Without Konsta UI, HTML would require much higher tolerance (0.15+) due to major styling differences
- Focus on structural equivalence over pixel-perfect matching
- Document expected differences (e.g., "HTML uses web fonts vs SF Pro")
- Use visual diff images for review
- Konsta UI significantly reduces HTML vs native differences, making consistency tests more meaningful

## 6. Maintenance Strategy

### 6.1 Updating Snapshots

To update snapshots, modify your test code to use recording mode:

```swift
// Option 1: Update all snapshots in a test
func testTextWithBasicStyle() async throws {
    withSnapshotTesting(record: .all) {
        assertSnapshot(of: image, as: .image)
    }
}

// Option 2: Update specific assertion
assertSnapshot(of: image, as: .image, record: .all)

// Option 3: Update only failed snapshots
withSnapshotTesting(record: .failed) {
    // tests
}
```

Then run your tests:
```bash
xcodebuild test -scheme ScalsRenderer \
  -destination 'platform=iOS Simulator,name=iPhone 15 Pro' \
  -only-testing:ScalsModulesTests/TextNodeSnapshotTests
```

### 6.2 Reviewing Snapshot Changes
1. Run tests locally to see failures
2. Use SnapshotTesting's diff images in test results (check test attachments in Xcode)
3. Review changed snapshots in `__Snapshots__/` directory
4. If intentional, re-record with `record: .all` as shown above
5. Remove the `record:` parameter after updating snapshots
6. Commit updated snapshots with descriptive message

### 6.3 Adding New Components
1. Add component implementation to renderer
2. Create snapshot test in `Components/` directory
3. Add to appropriate test tier
4. Record initial snapshots (use `record: .all` on first run)
5. Add cross-renderer consistency test
6. Add canonical comparison test with inline SwiftUI view

### 6.4 Handling Breaking Changes
1. Document reason for snapshot changes in PR
2. Show before/after snapshots in PR description
3. Get team approval before merging
4. Consider backward compatibility period

## 7. CI/CD Integration

### 7.1 GitHub Actions Workflow
```yaml
name: Snapshot Tests

on: [pull_request, push]

jobs:
  tier1-smoke-tests:
    runs-on: macos-14
    steps:
      - uses: actions/checkout@v4
        with:
          lfs: true
      - name: Select Xcode
        run: sudo xcode-select -s /Applications/Xcode_15.2.app
      - name: Run Tier 1 Tests
        run: xcodebuild test -scheme ScalsRenderer -destination 'platform=iOS Simulator,name=iPhone 15 Pro'
      - name: Upload failures
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: snapshot-failures
          path: ScalsModulesTests/__Snapshots__/

  tier2-pr-tests:
    runs-on: macos-14
    if: github.event_name == 'pull_request'
    steps:
      - uses: actions/checkout@v4
        with:
          lfs: true
      - name: Run Tier 2 Tests
        run: xcodebuild test -scheme ScalsRenderer -destination 'platform=iOS Simulator,name=iPhone 15 Pro'
```

### 7.2 Test Organization Strategy

With XCTest, organize tests by test class naming conventions:

```swift
// Tier 1: Smoke tests (run on every commit)
// Naming: *SnapshotTests.swift
TextNodeSnapshotTests
ButtonNodeSnapshotTests
ImageNodeSnapshotTests

// Tier 2: Component coverage (run on PR)
// All snapshot test classes

// Tier 3: Cross-renderer consistency (run nightly)
// Naming: *ConsistencyTests.swift
ComponentConsistencyTests
LayoutConsistencyTests

// Tier 4: Full integration (run weekly)
// Naming: *CanonicalTests.swift, *ExamplesTests.swift
ComponentExamplesSnapshotTests
CanonicalComparisonTests
```

**Running specific test tiers:**

```bash
# Run specific test class
xcodebuild test -scheme ScalsRenderer -only-testing:ScalsModulesTests/TextNodeSnapshotTests

# Run multiple test classes (Tier 1)
xcodebuild test -scheme ScalsRenderer \
  -only-testing:ScalsModulesTests/TextNodeSnapshotTests \
  -only-testing:ScalsModulesTests/ButtonNodeSnapshotTests

# Run all consistency tests (Tier 3)
xcodebuild test -scheme ScalsRenderer -only-testing:ScalsModulesTests/ComponentConsistencyTests
```

## 8. Test Verification Workflow

Every test must go through an iterative verification process to ensure quality and catch renderer bugs early. Follow this workflow for each test:

### 8.1 Single Test Development Cycle

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. Write Test                                                ‚îÇ
‚îÇ    - Create test method for single component/scenario       ‚îÇ
‚îÇ    - Choose appropriate snapshot size                       ‚îÇ
‚îÇ    - Use descriptive test name                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
                     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 2. Record Initial Snapshot                                   ‚îÇ
‚îÇ    - Run test with record: .all                             ‚îÇ
‚îÇ    - Inspect snapshot image visually                        ‚îÇ
‚îÇ    - Verify it looks correct                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
                     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 3. Run Test (Remove record mode)                            ‚îÇ
‚îÇ    - Run test normally                                      ‚îÇ
‚îÇ    - Check if it passes                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
                     ‚ñº
                  Passes? ‚îÄ‚îÄ‚îÄYes‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                     ‚îÇ                                     ‚îÇ
                     No                                    ‚îÇ
                     ‚îÇ                                     ‚ñº
                     ‚ñº                              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ 7. Success!  ‚îÇ
‚îÇ 4. Analyze Failure                       ‚îÇ        ‚îÇ   - Commit   ‚îÇ
‚îÇ    Open test failure details            ‚îÇ        ‚îÇ   - Move on  ‚îÇ
‚îÇ    Check diff images in test results    ‚îÇ        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ    Determine root cause:                ‚îÇ
‚îÇ    a) Tolerance too strict?             ‚îÇ
‚îÇ    b) Renderer bug?                     ‚îÇ
‚îÇ    c) SCALS framework bug?              ‚îÇ
‚îÇ    d) Test setup issue?                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ
                 ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 5. Fix & Iterate                                             ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ    If tolerance issue:                                       ‚îÇ
‚îÇ    - Increase tolerance slightly (0.01-0.02 increments)     ‚îÇ
‚îÇ    - Document why in test comment                           ‚îÇ
‚îÇ    - Go back to Step 3                                      ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ    If renderer/SCALS bug:                                    ‚îÇ
‚îÇ    - Fix the bug in renderer or SCALS code                  ‚îÇ
‚îÇ    - Re-record snapshot if visual output changed           ‚îÇ
‚îÇ    - Go back to Step 3                                      ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ    If test setup issue:                                      ‚îÇ
‚îÇ    - Fix test code (size, node configuration, etc.)         ‚îÇ
‚îÇ    - Re-record snapshot                                     ‚îÇ
‚îÇ    - Go back to Step 3                                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ
                 ‚ñº
          Iteration count > 10? ‚îÄ‚îÄ‚îÄNo‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                 ‚îÇ                        ‚îÇ
                Yes                       ‚îÇ
                 ‚îÇ                        ‚îÇ
                 ‚ñº                        ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ 6. Document & Revert                ‚îÇ  ‚îÇ
‚îÇ    - Add to FAILING_TESTS.md        ‚îÇ  ‚îÇ
‚îÇ    - Document symptoms & attempts   ‚îÇ  ‚îÇ
‚îÇ    - Revert all test changes        ‚îÇ  ‚îÇ
‚îÇ    - Move to next test              ‚îÇ  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
                                         ‚îÇ
                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ
                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Continue iteration
```

### 8.2 Detailed Step-by-Step Process

#### Step 1: Write Test
```swift
@MainActor
func testButtonWithBasicStyle() async throws {
    let node = RenderNode.button(ButtonNode(
        label: "Tap Me",
        styles: ButtonStyles(
            normal: IR.Style(
                backgroundColor: .systemBlue,
                textColor: .white,
                padding: EdgeInsets(top: 12, leading: 16, bottom: 12, trailing: 16)
            )
        ),
        onTap: ActionBinding(action: .none)
    ))

    let image = await RendererTestHelpers.renderSwiftUI(
        node,
        size: StandardSnapshotSizes.standard
    )

    assertSnapshot(of: image, as: .image, named: "button-basic")
}
```

#### Step 2: Record Initial Snapshot
```bash
# 1. Add record mode to test
withSnapshotTesting(record: .all) {
    assertSnapshot(of: image, as: .image, named: "button-basic")
}

# 2. Run test
xcodebuild test -scheme ScalsRenderer \
  -destination 'platform=iOS Simulator,name=iPhone 13' \
  -only-testing:ScalsModulesTests/ButtonNodeSnapshotTests/testButtonWithBasicStyle

# 3. Visually inspect snapshot
open ScalsModulesTests/__Snapshots__/ButtonNodeSnapshotTests/button-basic.png

# 4. Verify it looks correct:
#    - Button is visible
#    - Colors are correct
#    - Size is appropriate
#    - No clipping or layout issues
```

#### Step 3: Run Test Without Recording
```swift
// Remove record mode
assertSnapshot(of: image, as: .image, named: "button-basic")
```

Run test and check result:
```bash
xcodebuild test -scheme ScalsRenderer \
  -destination 'platform=iOS Simulator,name=iPhone 13' \
  -only-testing:ScalsModulesTests/ButtonNodeSnapshotTests/testButtonWithBasicStyle
```

#### Step 4: Analyze Failure

If test fails, check Xcode test results:
1. Look at failure message in test navigator
2. View diff images in test report
3. Check for rendering differences

**Common failure causes:**

**A) Tolerance Issue (Minor anti-aliasing differences)**
```
Difference: 0.0023 (threshold: 0.01)
Symptom: Tiny pixel differences around edges
Solution: Increase tolerance
```

**B) Renderer Bug**
```
Symptom: Button not rendering at all
Symptom: Wrong colors being used
Symptom: Layout completely broken
Solution: Fix renderer code
```

**C) SCALS Framework Bug**
```
Symptom: IR Style not being applied
Symptom: State not propagating correctly
Solution: Fix SCALS framework
```

**D) Test Setup Issue**
```
Symptom: Component too small/large for snapshot size
Symptom: Wrong component configuration
Solution: Fix test setup
```

#### Step 5: Fix & Iterate

**Example: Tolerance Issue**
```swift
// Iteration 1: Failed with default tolerance
assertSnapshot(of: image, as: .image, named: "button-basic")
// Error: Difference 0.0023, threshold 0.0

// Iteration 2: Add tolerance
assertSnapshot(
    of: image,
    as: .image(perceptualPrecision: 0.98), // Allow 2% difference
    named: "button-basic"
)
// Success!

// Add comment explaining tolerance
// Note: Using 0.98 precision due to minor anti-aliasing differences
// in button corner rendering between test runs
```

**Example: Renderer Bug**
```swift
// Iteration 1: Button not rendering
// Analysis: SwiftUIRenderer not handling ButtonNode padding correctly

// Fix in SwiftUIRenderer.swift:
func render(_ node: ButtonNode) -> some View {
    Button(action: { /* ... */ }) {
        Text(node.label)
    }
    .padding(node.styles.normal.padding) // ‚Üê Added this line
}

// Iteration 2: Re-record snapshot
// Iteration 3: Test passes!
```

**Example: Test Setup Issue**
```swift
// Iteration 1: Button clipped
let image = await RendererTestHelpers.renderSwiftUI(
    node,
    size: StandardSnapshotSizes.compact // Too small!
)

// Iteration 2: Fix size
let image = await RendererTestHelpers.renderSwiftUI(
    node,
    size: StandardSnapshotSizes.standard // Better!
)
// Re-record and test passes!
```

#### Step 6: Document & Revert (After 10+ Failed Iterations)

If a test cannot be made to pass after ~10 iterations, document it and move on:

```bash
# 1. Create/update FAILING_TESTS.md
cat >> FAILING_TESTS.md << 'EOF'

## ButtonNodeSnapshotTests.testButtonWithComplexGradient

**Date**: 2024-01-27
**Status**: Unable to stabilize
**Symptom**: Gradient rendering produces different output on each test run
**Attempts**: 12 iterations
- Tried tolerance values from 0.95 to 0.80
- Investigated SwiftUIRenderer gradient code
- Suspected iOS gradient rendering non-determinism

**Next Steps**:
- Research SwiftUI gradient snapshot testing best practices
- Consider alternative approach (test gradient properties instead of visual)
- May need to skip visual testing for gradients

**Related Issues**: None yet

EOF

# 2. Revert all changes from this test
git checkout -- ScalsModulesTests/SnapshotTests/Components/ButtonNodeSnapshotTests.swift
git checkout -- ScalsModules/SwiftUI/ButtonNodeSwiftUIRenderer.swift  # if you modified this
git clean -fd ScalsModulesTests/__Snapshots__/ButtonNodeSnapshotTests/

# 3. Move to next test
```

#### Step 7: Commit Successful Test

When test passes consistently:

```bash
# 1. Run test multiple times to ensure stability
for i in {1..5}; do
  xcodebuild test -scheme ScalsRenderer \
    -destination 'platform=iOS Simulator,name=iPhone 13' \
    -only-testing:ScalsModulesTests/ButtonNodeSnapshotTests/testButtonWithBasicStyle
done

# 2. Commit test + any code changes
git add ScalsModulesTests/SnapshotTests/Components/ButtonNodeSnapshotTests.swift
git add ScalsModulesTests/__Snapshots__/ButtonNodeSnapshotTests/

# If you fixed renderer bugs:
git add ScalsModules/SwiftUI/ButtonNodeSwiftUIRenderer.swift

# Commit with descriptive message
git commit -m "Add snapshot test for basic button rendering

- Tests ButtonNode with standard styling (blue background, white text)
- Includes padding and corner radius
- Uses 0.98 perceptual precision for anti-aliasing tolerance
- Fixed padding application in SwiftUIRenderer

Co-Authored-By: Claude (us.anthropic.claude-sonnet-4-5-20250929-v1:0) <noreply@anthropic.com>"

# 3. Move to next test
```

### 8.3 Tracking Progress

Maintain a checklist of tests to implement:

```markdown
# SNAPSHOT_TEST_PROGRESS.md

## Components - Tier 1 (Smoke Tests)

### TextNode
- [x] testTextWithBasicStyle (commit: abc123)
- [x] testTextWithColorSchemes (commit: def456)
- [ ] testTextWithMultipleFontWeights
- [ ] testTextWithAlignment

### ButtonNode
- [x] testButtonWithBasicStyle (commit: ghi789)
- [ ] testButtonWithDisabledState
- [ ] testButtonWithCustomColors
- [x] ~~testButtonWithComplexGradient~~ (See FAILING_TESTS.md)

### ImageNode
- [ ] testImageWithLocalAsset
- [ ] testImageWithRemoteURL
- [ ] testImageWithAspectFit
- [ ] testImageWithAspectFill
```

### 8.4 Best Practices

**Do:**
- ‚úÖ Test one thing at a time (single component, single scenario)
- ‚úÖ Commit after each successful test
- ‚úÖ Document tolerance reasoning in comments
- ‚úÖ Fix renderer bugs as you discover them
- ‚úÖ Revert cleanly after failing tests
- ‚úÖ Keep iteration count reasonable (~10 max)

**Don't:**
- ‚ùå Write multiple tests before running any
- ‚ùå Commit failing tests "to fix later"
- ‚ùå Use extremely high tolerance to force pass (>0.20)
- ‚ùå Skip visual inspection of snapshots
- ‚ùå Leave failing test code uncommitted
- ‚ùå Continue iterating indefinitely on a failing test

### 8.5 Tolerance Guidelines

Start with default (exact match) and increase as needed:

| Precision | Tolerance | Use Case |
|-----------|-----------|----------|
| 1.0 | 0% | Static images, exact matches |
| 0.99 | 1% | Minor anti-aliasing differences |
| 0.98 | 2% | SwiftUI vs UIKit (native renderers) |
| 0.95 | 5% | HTML with Konsta UI vs native |
| 0.92 | 8% | HTML with Konsta UI (complex components) |
| 0.90 | 10% | Maximum for visual consistency tests |
| <0.90 | >10% | Too high - investigate root cause |

If you need >10% tolerance, the test is likely catching a real bug.

### 8.6 Example Workflow Session

```bash
# Session: Implementing TextNode snapshot tests

# Test 1: Basic text
vim ScalsModulesTests/SnapshotTests/Components/TextNodeSnapshotTests.swift
# Write testTextWithBasicStyle
# Record snapshot
# Run test ‚Üí PASS ‚úÖ
git add . && git commit -m "Add snapshot test for basic text"

# Test 2: Color schemes
# Add testTextWithColorSchemes to same file
# Record snapshots (light & dark)
# Run test ‚Üí FAIL ‚ùå (dark mode has 0.015 difference)
# Increase tolerance to 0.98
# Run test ‚Üí PASS ‚úÖ
git add . && git commit -m "Add snapshot test for text color schemes"

# Test 3: Custom fonts
# Add testTextWithCustomFont
# Record snapshot
# Run test ‚Üí FAIL ‚ùå (font not loading)
# Fix: Font not registered in test bundle
# Fix font registration in test setup
# Re-record snapshot
# Run test ‚Üí PASS ‚úÖ
git add . && git commit -m "Add snapshot test for text with custom font

Fixed: Register custom fonts in test bundle setup"

# Test 4: Complex text attributes
# Add testTextWithComplexAttributes
# Record snapshot
# Run test ‚Üí FAIL ‚ùå (attributed string not rendering)
# Investigate SwiftUIRenderer
# Try various fixes ‚Üí 12 iterations ‚Üí Still failing
# Document in FAILING_TESTS.md
git checkout -- ScalsModulesTests/SnapshotTests/Components/TextNodeSnapshotTests.swift
# Move to next component

# End of session: 3 passing tests committed, 1 documented as failing
```

### 8.7 Autonomous Operation

**IMPORTANT: This workflow is designed to run autonomously without human intervention.**

When implementing snapshot tests:
- ‚úÖ **DO** make all decisions independently (tolerance values, bug fixes, test reverts)
- ‚úÖ **DO** continue iterating through all planned tests automatically
- ‚úÖ **DO** commit passing tests immediately
- ‚úÖ **DO** document failing tests and move on
- ‚úÖ **DO** fix bugs in renderers/SCALS as discovered
- ‚ùå **DO NOT** ask for permission before making changes
- ‚ùå **DO NOT** wait for approval to increase tolerance
- ‚ùå **DO NOT** stop and ask whether to fix a bug or adjust tolerance
- ‚ùå **DO NOT** request review before committing

**The process runs continuously until:**
- All planned test cases are completed (passing or documented as failing)
- The current phase is finished
- An unrecoverable error occurs (e.g., simulator crashes, build failures)

**Progress Monitoring:**
The human can monitor progress by checking:
- `SNAPSHOT_TEST_PROGRESS.md` - Current status and completed tests
- `FAILING_TESTS.md` - Tests that couldn't be stabilized
- Git commits - Each passing test is committed
- Terminal output - Real-time iteration feedback

### 8.8 Git Branching Strategy for Phases

To enable clean reverts of entire phases if needed, use a branching strategy:

```bash
# Start from main branch
git checkout main

# Phase 1: Foundation
git checkout -b snapshot-tests/phase-1-foundation
# Implement Phase 1 tests...
# Tests committed individually as they pass
# When phase complete:
git checkout main
git merge snapshot-tests/phase-1-foundation
git tag snapshot-tests-phase-1-complete
git push origin main --tags

# Phase 2: Core Components
git checkout -b snapshot-tests/phase-2-components
# Implement Phase 2 tests...
# Tests committed individually as they pass
# When phase complete:
git checkout main
git merge snapshot-tests/phase-2-components
git tag snapshot-tests-phase-2-complete
git push origin main --tags

# And so on for each phase...
```

**Reverting a Phase:**
If a phase needs to be reverted entirely:

```bash
# Option 1: Revert to before phase started
git reset --hard snapshot-tests-phase-1-complete  # Go back to end of Phase 1
git branch -D snapshot-tests/phase-2-components    # Delete phase branch

# Option 2: Keep history but undo changes
git revert snapshot-tests-phase-1-complete..HEAD  # Revert all Phase 2 commits

# Option 3: Cherry-pick good commits
git checkout -b snapshot-tests/phase-2-retry
git cherry-pick <commit1> <commit2>  # Pick only the working tests
```

**Phase Branch Naming Convention:**
- `snapshot-tests/phase-1-foundation`
- `snapshot-tests/phase-2-components`
- `snapshot-tests/phase-3-cross-renderer`
- `snapshot-tests/phase-4-examples`
- `snapshot-tests/phase-5-canonical`
- `snapshot-tests/phase-6-polish`

**Within-Phase Savepoints:**
For long phases (e.g., Phase 2 with 10 components), create savepoints:

```bash
# After completing TextNode tests
git tag snapshot-tests-phase-2-textnode-complete

# After completing ButtonNode tests
git tag snapshot-tests-phase-2-buttonnode-complete

# If ButtonNode tests need to be reverted:
git reset --hard snapshot-tests-phase-2-textnode-complete
```

**Autonomous Phase Execution:**

```bash
#!/bin/bash
# autonomous-phase-execution.sh

PHASE="phase-2-components"
BRANCH="snapshot-tests/$PHASE"

# Create phase branch
git checkout main
git checkout -b "$BRANCH"

echo "Starting autonomous test implementation for $PHASE"
echo "This will run until all tests are complete or max iterations reached"
echo "Monitor progress in SNAPSHOT_TEST_PROGRESS.md"

# Start autonomous test implementation
# (This would invoke Claude to implement tests autonomously)

# When complete
git checkout main
git merge "$BRANCH"
git tag "snapshot-tests-$PHASE-complete"

echo "Phase complete. Review SNAPSHOT_TEST_PROGRESS.md and FAILING_TESTS.md"
```

## 9. Implementation Phases

**Execution Mode**: Autonomous - runs continuously without human intervention
**Branching Strategy**: Each phase on separate branch for clean revert capability

### Phase 1: Foundation (Week 1)

**Branch**: `snapshot-tests/phase-1-foundation`

**Goal**: Set up infrastructure and prove viability

**Setup**:
```bash
git checkout main
git checkout -b snapshot-tests/phase-1-foundation
echo "# Snapshot Test Progress" > SNAPSHOT_TEST_PROGRESS.md
echo "# Failing Tests" > FAILING_TESTS.md
git add . && git commit -m "Initialize snapshot test tracking documents"
```

**Tasks**:
- [ ] Add swift-snapshot-testing to Package.swift (or Xcode project)
- [ ] Configure Git LFS for `__Snapshots__/` directory
- [ ] Create test directory structure in ScalsModulesTests/SnapshotTests/
- [ ] Implement StandardSnapshotSizes helper
- [ ] Implement RendererTestHelpers.renderSwiftUI()
- [ ] Create TextNodeSnapshotTests.swift
- [ ] Write + verify first test: testTextWithBasicStyle
  - Follow verification workflow (Section 8)
  - Iterate until passing
  - Commit when passing

**Completion**:
```bash
git checkout main
git merge snapshot-tests/phase-1-foundation
git tag snapshot-tests-phase-1-complete
git push origin main --tags
```

**Deliverables**:
- Test infrastructure in place
- 1+ passing snapshot test
- Verified snapshot workflow
- Progress tracking documents initialized

---

### Phase 2: Core Components (Week 2)

**Branch**: `snapshot-tests/phase-2-components`

**Goal**: Cover Tier 1 components with SwiftUI and UIKit

**Setup**:
```bash
git checkout main
git checkout -b snapshot-tests/phase-2-components
```

**Tasks** (Autonomous - no approval needed):

**TextNode Tests** (Savepoint after completion)
- [ ] testTextWithBasicStyle (SwiftUI)
- [ ] testTextWithColorSchemes (SwiftUI)
- [ ] testTextWithFontWeights (SwiftUI)
- [ ] testTextWithAlignment (SwiftUI)
- [ ] testTextWithBasicStyle (UIKit)
- [ ] testTextWithColorSchemes (UIKit)
- Tag: `snapshot-tests-phase-2-textnode-complete`

**ButtonNode Tests** (Savepoint after completion)
- [ ] testButtonWithBasicStyle (SwiftUI)
- [ ] testButtonWithDisabledState (SwiftUI)
- [ ] testButtonWithCustomColors (SwiftUI)
- [ ] testButtonWithBasicStyle (UIKit)
- [ ] testButtonWithDisabledState (UIKit)
- Tag: `snapshot-tests-phase-2-buttonnode-complete`

**ImageNode Tests**
- [ ] testImageWithLocalAsset (SwiftUI)
- [ ] testImageWithAspectFit (SwiftUI)
- [ ] testImageWithAspectFill (SwiftUI)
- [ ] testImageWithLocalAsset (UIKit)
- Tag: `snapshot-tests-phase-2-imagenode-complete`

**Continue for remaining Tier 1 components:**
- [ ] VStackNode tests (SwiftUI + UIKit)
- [ ] HStackNode tests (SwiftUI + UIKit)
- [ ] ZStackNode tests (SwiftUI + UIKit)
- [ ] ListNode tests (SwiftUI + UIKit)
- [ ] ScrollViewNode tests (SwiftUI + UIKit)
- [ ] SpacerNode tests (SwiftUI + UIKit)
- [ ] DividerNode tests (SwiftUI + UIKit)

**Additional Phase 2 Tasks**:
- [ ] Implement RendererTestHelpers.renderUIKit()
- [ ] Implement RendererComparisonHelper (basic version)
- [ ] Create CI workflow for Tier 1 tests

**Autonomous Operation**:
- Iterate through each component systematically
- Follow verification workflow for each test
- Commit each passing test individually
- Document failing tests in FAILING_TESTS.md
- Fix renderer bugs as discovered
- No human approval required

**Completion**:
```bash
git checkout main
git merge snapshot-tests/phase-2-components
git tag snapshot-tests-phase-2-complete
git push origin main --tags
```

---

### Phase 3: Cross-Renderer Testing (Week 3)

**Branch**: `snapshot-tests/phase-3-cross-renderer`

**Goal**: Verify renderer consistency with HTML renderer

**Setup**:
```bash
git checkout main
git checkout -b snapshot-tests/phase-3-cross-renderer
npm install konsta  # Install Konsta UI
```

**Tasks** (Autonomous):
- [ ] Update HTML renderer to use Konsta UI classes
- [ ] Implement RendererTestHelpers.renderHTMLTree()
- [ ] Implement RendererComparisonHelper.assertStructuralEquivalence()
- [ ] Create ComponentConsistencyTests.swift
- [ ] Test cross-renderer consistency for each Tier 1 component
  - testTextNodeConsistency (SwiftUI vs UIKit vs HTML)
  - testButtonNodeConsistency
  - testImageNodeConsistency
  - (Continue for all Tier 1 components)
- [ ] Document tolerance decisions for HTML renderer
- [ ] Generate diff images for failures
- [ ] Update SNAPSHOT_TEST_PROGRESS.md with cross-renderer results

**Autonomous Operation**:
- Adjust HTML renderer styling to match iOS
- Tune tolerance values (start at 0.95 for HTML)
- Fix renderer inconsistencies as discovered
- Document expected differences (fonts, anti-aliasing)

**Completion**:
```bash
git checkout main
git merge snapshot-tests/phase-3-cross-renderer
git tag snapshot-tests-phase-3-complete
git push origin main --tags
```

---

### Phase 4: Example Integration (Week 4)

**Branch**: `snapshot-tests/phase-4-examples`

**Goal**: Test all 48 examples

**Setup**:
```bash
git checkout main
git checkout -b snapshot-tests/phase-4-examples
```

**Tasks** (Autonomous):
- [ ] Implement ExampleDataLoader
- [ ] Create SmokeTestExamplesSnapshotTests.swift
- [ ] Create FullExampleCoverageSnapshotTests.swift
- [ ] Test all examples with each renderer:
  - ExampleDataLoader.smokeTestExamples (SwiftUI, UIKit, HTML)
  - ExampleDataLoader.layoutExamples (SwiftUI, UIKit, HTML)
  - ExampleDataLoader.complexExamples (SwiftUI, UIKit, HTML)
  - All 48 examples (SwiftUI, UIKit, HTML)
- [ ] Categorize examples by complexity
- [ ] Optimize test performance (parallel execution)

**Autonomous Operation**:
- Process examples in batches
- Commit after each example subset passes
- Document complex examples that fail
- Fix bugs in example IR if discovered

**Completion**:
```bash
git checkout main
git merge snapshot-tests/phase-4-examples
git tag snapshot-tests-phase-4-complete
git push origin main --tags
```

---

### Phase 5: Canonical References (Week 5)

**Branch**: `snapshot-tests/phase-5-canonical`

**Goal**: Validate against pure SwiftUI/UIKit implementations

**Setup**:
```bash
git checkout main
git checkout -b snapshot-tests/phase-5-canonical
```

**Tasks** (Autonomous):
- [ ] Implement RendererTestHelpers.renderCanonicalView()
- [ ] Create CanonicalComparisonTests.swift
- [ ] Test each Tier 1 component against canonical:
  - testTextNodeVsCanonicalSwiftUI
  - testButtonNodeVsCanonicalSwiftUI
  - testImageNodeVsCanonicalSwiftUI
  - (Continue for all Tier 1 components)
- [ ] Document differences from canonical implementations
- [ ] Tune tolerance for canonical comparisons (0.95-0.98)
- [ ] Create comparison reports

**Autonomous Operation**:
- Write inline canonical views for each test
- Compare SCALS output vs pure SwiftUI/UIKit
- Document expected differences
- Fix renderer bugs if output differs significantly

**Completion**:
```bash
git checkout main
git merge snapshot-tests/phase-5-canonical
git tag snapshot-tests-phase-5-complete
git push origin main --tags
```

---

### Phase 6: Polish and Documentation (Week 6)

**Branch**: `snapshot-tests/phase-6-polish`

**Goal**: Finalize and document the test suite

**Setup**:
```bash
git checkout main
git checkout -b snapshot-tests/phase-6-polish
```

**Tasks** (Autonomous):
- [ ] Review all failing tests in FAILING_TESTS.md
  - Retry failed tests with updated code
  - Document permanent failures with workarounds
- [ ] Optimize test performance:
  - Enable parallel test execution
  - Reduce redundant rendering
  - Cache common setups
- [ ] Set up CI workflows:
  - Tier 1 (on every commit)
  - Tier 2 (on PR)
  - Tier 3 (nightly)
  - Tier 4 (weekly)
- [ ] Create snapshot update scripts
- [ ] Write maintenance documentation
- [ ] Review and finalize SNAPSHOT_TEST_PROGRESS.md
- [ ] Create summary report of test coverage

**Completion**:
```bash
git checkout main
git merge snapshot-tests/phase-6-polish
git tag snapshot-tests-phase-6-complete
git push origin main --tags
```

---

### Phase Execution Summary

**Total Estimated Tests**: ~85 tests
- Phase 1: 1 test (proof of concept)
- Phase 2: ~30 tests (10 components √ó 3 tests avg)
- Phase 3: ~10 tests (consistency for each component)
- Phase 4: ~48 tests (all examples)
- Phase 5: ~10 tests (canonical comparisons)
- Phase 6: Optimization and documentation

**Autonomous Execution**: All phases run without human approval
**Savepoints**: Tagged after each component group
**Rollback**: Reset to any tag if needed
**Progress**: Track in SNAPSHOT_TEST_PROGRESS.md

## 9. Project Dependencies

### Package.swift Addition
```swift
dependencies: [
    .package(url: "https://github.com/pointfreeco/swift-snapshot-testing", from: "1.15.0")
],
targets: [
    .testTarget(
        name: "ScalsModulesTests",
        dependencies: [
            "SCALS",
            "ScalsModules",
            .product(name: "SnapshotTesting", package: "swift-snapshot-testing")
        ]
    )
]
```

### Git LFS Setup
```bash
git lfs track "ScalsModulesTests/__Snapshots__/**/*.png"
git add .gitattributes
git commit -m "Configure Git LFS for snapshot images"
```

### Konsta UI Setup for HTML Renderer

[Konsta UI](https://github.com/konstaui/konsta) is a mobile UI library that provides pixel-perfect iOS and Material Design components in HTML/CSS/JS. For snapshot testing, we'll use Konsta UI to make the HTML renderer output visually consistent with native iOS renderers.

**Installation:**
```bash
npm install konsta
# or
yarn add konsta
```

**Integration with HTML Renderer:**

The HTML renderer should include Konsta UI's iOS theme:

```html
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="stylesheet" href="path/to/konsta/css/konsta.min.css">
    <style>
        /* iOS theme setup */
        :root {
            --k-theme-color: #007aff;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
    </style>
</head>
<body class="k-ios">
    <!-- Rendered components using Konsta classes -->
</body>
</html>
```

**Component Mapping Examples:**

Map SCALS IR components to Konsta UI classes:

```swift
// TextNode ‚Üí Konsta Text
<div class="k-text-ios">Hello World</div>

// ButtonNode ‚Üí Konsta Button
<button class="k-button k-button-filled k-button-ios">Tap Me</button>

// ListNode ‚Üí Konsta List
<div class="k-list k-list-ios">
    <ul>
        <li class="k-list-item">Item 1</li>
        <li class="k-list-item">Item 2</li>
    </ul>
</div>

// VStackNode ‚Üí Konsta Block
<div class="k-block k-block-ios">
    <!-- Children stacked vertically -->
</div>
```

**Benefits:**
- iOS-accurate styling (colors, fonts, spacing, shadows)
- Built-in light/dark mode support via CSS classes
- Reduces visual differences between HTML and native renderers
- Makes cross-renderer consistency tests more meaningful
- Easier tolerance tuning (smaller differences = tighter tolerances)

## 10. Success Criteria

### Functional Requirements
- ‚úÖ All RenderNode types have snapshot tests
- ‚úÖ SwiftUI, UIKit, and HTML renderers tested
- ‚úÖ Cross-renderer consistency validated
- ‚úÖ All 48 examples tested
- ‚úÖ Canonical comparisons implemented

### Performance Requirements
- ‚úÖ Tier 1 tests complete in <2 minutes
- ‚úÖ Tier 2 tests complete in <5 minutes
- ‚úÖ Full suite completes in <30 minutes
- ‚úÖ Tests can run in parallel

### Quality Requirements
- ‚úÖ <3% difference between SwiftUI/UIKit
- ‚úÖ 1px tolerance for regressions
- ‚úÖ No flaky tests
- ‚úÖ Clear diff images on failure
- ‚úÖ Documented expected differences

### Developer Experience
- ‚úÖ Simple snapshot update workflow
- ‚úÖ Clear failure messages
- ‚úÖ Fast feedback in CI
- ‚úÖ Easy to add new tests
- ‚úÖ Good documentation

## 11. Future Enhancements

### Post-V1 Improvements
1. **Interactive Snapshot Review Tool**: Web UI for reviewing snapshot changes
2. **Automated Diff Reports**: Generate HTML reports with side-by-side comparisons
3. **Accessibility Snapshots**: Test with VoiceOver, Dynamic Type, reduced motion
4. **Animation Snapshots**: Capture animation sequences as video or frame series
5. **Responsive Testing**: Test HTML renderer at multiple viewport sizes
6. **Performance Baselines**: Track rendering performance alongside visual output
7. **Fuzzing**: Generate random IR trees to find edge cases
8. **Snapshot Compression**: Use perceptual hashing to reduce storage

---

## Appendix A: Test File Templates

### Component Test Template
```swift
import XCTest
import SnapshotTesting
import SCALS
import ScalsModules

final class [ComponentName]SnapshotTests: XCTestCase {

    @MainActor
    func test[Component]WithBasicStyle() async throws {
        let node = RenderNode.[nodeType]([NodeType](
            // Configure node
        ))

        let image = await RendererTestHelpers.renderSwiftUI(
            node,
            size: StandardSnapshotSizes.compact  // Choose: compact, standard, medium, large, or custom(height:)
        )

        assertSnapshot(
            of: image,
            as: .image,
            named: "[component]-basic"
        )
    }

    // Add more test cases
}
```

### Cross-Renderer Test Template
```swift
import XCTest
import SnapshotTesting
import SCALS
import ScalsModules

final class [Component]ConsistencyTests: XCTestCase {

    @MainActor
    func test[Component]Consistency() async throws {
        let node = RenderNode.[nodeType]([NodeType](
            // Configure node
        ))

        // Choose appropriate size based on component content
        let size = StandardSnapshotSizes.standard

        let swiftUIImage = await RendererTestHelpers.renderSwiftUI(node, size: size)
        let uikitImage = await RendererTestHelpers.renderUIKit(node, size: size)

        assertSnapshot(of: swiftUIImage, as: .image, named: "[component]-swiftui")
        assertSnapshot(of: uikitImage, as: .image, named: "[component]-uikit")

        try RendererComparisonHelper.assertStructuralEquivalence(
            swiftUIImage,
            uikitImage,
            tolerance: 0.03,
            named: "[component]-consistency"
        )
    }
}
```

### Canonical Comparison Test Template
```swift
import XCTest
import SwiftUI
import SnapshotTesting
import SCALS
import ScalsModules

final class [Component]CanonicalTests: XCTestCase {

    @MainActor
    func test[Component]VsCanonicalSwiftUI() async throws {
        // Create SCALS IR node
        let node = RenderNode.[nodeType]([NodeType](
            // Configure node
        ))

        // Choose appropriate size
        let size = StandardSnapshotSizes.standard

        // Render with SCALS
        let scalsImage = await RendererTestHelpers.renderSwiftUI(node, size: size)

        // Render canonical SwiftUI inline
        let canonicalImage = await RendererTestHelpers.renderCanonicalView(size: size) {
            // Pure SwiftUI implementation
            Text("Example")
                .font(.system(size: 16))
        }

        // Compare
        assertSnapshot(of: scalsImage, as: .image, named: "[component]-scals")
        assertSnapshot(of: canonicalImage, as: .image, named: "[component]-canonical")

        try RendererComparisonHelper.assertStructuralEquivalence(
            scalsImage,
            canonicalImage,
            tolerance: 0.05,
            named: "[component]-vs-canonical"
        )
    }
}
```

---

## Appendix B: Useful Commands

```bash
# Run all tests
xcodebuild test -scheme ScalsRenderer -destination 'platform=iOS Simulator,name=iPhone 15 Pro'

# Run specific test class
xcodebuild test -scheme ScalsRenderer \
  -destination 'platform=iOS Simulator,name=iPhone 15 Pro' \
  -only-testing:ScalsModulesTests/TextNodeSnapshotTests

# Run specific test method
xcodebuild test -scheme ScalsRenderer \
  -destination 'platform=iOS Simulator,name=iPhone 15 Pro' \
  -only-testing:ScalsModulesTests/TextNodeSnapshotTests/testTextWithBasicStyle

# Record all snapshots (set environment variable)
# In test code, wrap with: withSnapshotTesting(record: .all) { /* tests */ }
# Or use inline: assertSnapshot(..., record: .all)

# Clean build folder
rm -rf ~/Library/Developer/Xcode/DerivedData/ScalsRenderer-*

# View snapshot differences
open ScalsModulesTests/__Snapshots__/__Failures__/

# Check snapshot sizes
du -sh ScalsModulesTests/__Snapshots__/

# Git LFS status
git lfs ls-files

# Run tests from command line with pretty output
set -o pipefail && xcodebuild test \
  -scheme ScalsRenderer \
  -destination 'platform=iOS Simulator,name=iPhone 15 Pro' \
  | xcpretty
```

**Recording Snapshots:**

In your test code, use one of these approaches:

```swift
// Option 1: Record specific assertion
assertSnapshot(of: image, as: .image, record: .all)

// Option 2: Record all assertions in scope
func testSomething() async throws {
    withSnapshotTesting(record: .all) {
        assertSnapshot(of: image1, as: .image)
        assertSnapshot(of: image2, as: .image)
    }
}

// Option 3: Record only failed snapshots
withSnapshotTesting(record: .failed) {
    // tests
}
```

---

## Appendix C: Recommended Reading

- [swift-snapshot-testing Documentation](https://github.com/pointfreeco/swift-snapshot-testing)
- [XCTest Documentation](https://developer.apple.com/documentation/xctest)
- [UIKit View Rendering](https://developer.apple.com/documentation/uikit/uigraphicsimagerenderer)
- [SwiftUI Preview Testing](https://www.swiftbysundell.com/articles/snapshot-testing-in-swift/)
- [Point-Free Snapshot Testing Episodes](https://www.pointfree.co/collections/testing/snapshot-testing)
- [Konsta UI Documentation](https://konstaui.com) - iOS-styled HTML components
- [Konsta UI GitHub](https://github.com/konstaui/konsta) - Mobile UI components library

---

## Appendix D: Progress Tracking Document Templates

### SNAPSHOT_TEST_PROGRESS.md Template

Create this file at the root of your project to track test implementation progress:

```markdown
# Snapshot Test Implementation Progress

**Started**: 2024-01-27
**Status**: In Progress
**Current Phase**: Phase 2 - Core Components

## Summary

- **Total Tests Planned**: 85
- **Tests Passing**: 23
- **Tests Failing**: 2 (see FAILING_TESTS.md)
- **Tests Remaining**: 60
- **Code Fixes Made**: 8 renderer bugs, 3 SCALS bugs

## Components - Tier 1 (Smoke Tests)

### TextNode - SwiftUI
- [x] testTextWithBasicStyle (commit: abc123) ‚úÖ
- [x] testTextWithColorSchemes (commit: def456) ‚úÖ
- [x] testTextWithFontWeights (commit: ghi789) ‚úÖ
- [ ] testTextWithAlignment
- [ ] testTextWithLineLimit
- [x] ~~testTextWithAttributedString~~ (See FAILING_TESTS.md) ‚ùå

### TextNode - UIKit
- [x] testTextWithBasicStyle (commit: jkl012) ‚úÖ
- [ ] testTextWithColorSchemes
- [ ] testTextWithFontWeights

### ButtonNode - SwiftUI
- [x] testButtonWithBasicStyle (commit: mno345) ‚úÖ
  - Fixed: Padding not applied in SwiftUIRenderer
- [ ] testButtonWithDisabledState
- [ ] testButtonWithCustomColors
- [ ] testButtonWithAction

### ImageNode - SwiftUI
- [ ] testImageWithLocalAsset
- [ ] testImageWithAspectFit
- [ ] testImageWithAspectFill
- [ ] testImageWithContentMode

### VStackNode - SwiftUI
- [ ] testVStackWithBasicLayout
- [ ] testVStackWithSpacing
- [ ] testVStackWithAlignment

### HStackNode - SwiftUI
- [ ] testHStackWithBasicLayout
- [ ] testHStackWithSpacing
- [ ] testHStackWithAlignment

### ListNode - SwiftUI
- [ ] testListWithSimpleItems
- [ ] testListWithSections
- [ ] testListWithCustomRows

## Layouts - Tier 2

### (Add as you progress)

## Cross-Renderer Consistency - Tier 3

### (Add as you progress)

## Examples - Tier 4

### (Add as you progress)

## Bugs Fixed During Testing

1. **SwiftUIRenderer - ButtonNode padding** (commit: mno345)
   - Issue: Button padding from IR.Style not being applied
   - Fix: Added .padding() modifier in ButtonNodeSwiftUIRenderer

2. **SCALS - Color conversion** (commit: pqr678)
   - Issue: IR.Color alpha channel ignored in some cases
   - Fix: Updated color conversion logic in IR+SwiftUI extension

3. **UIKitRenderer - Text alignment** (commit: stu901)
   - Issue: Text alignment always defaulting to left
   - Fix: Apply textAlignment from IR.Style to UILabel

(Continue documenting bugs as discovered...)

## Notes

- Using iPhone 13 (390x844) for all snapshots
- Default tolerance: exact match (1.0 precision)
- Typical tolerance for anti-aliasing: 0.98-0.99 precision
- HTML renderer tolerance: 0.92-0.95 precision (with Konsta UI)

## Next Steps

1. Complete TextNode tests for all renderers
2. Move to ButtonNode tests
3. Document tolerance decisions in test comments
4. Set up CI for Tier 1 tests
```

### FAILING_TESTS.md Template

Create this file to document tests that couldn't be stabilized:

```markdown
# Failing Snapshot Tests

Tests that could not be made to pass after reasonable iteration attempts. These require further investigation or alternative approaches.

---

## TextNodeSnapshotTests.testTextWithAttributedString

**Date Added**: 2024-01-27
**Renderer**: SwiftUI
**Status**: Unable to stabilize after 12 iterations
**Priority**: Medium

### Symptom
AttributedString with multiple text styles produces non-deterministic rendering. Each test run produces slightly different output even with identical input.

### What We Tried

1. **Tolerance adjustments** (Iterations 1-5)
   - Tried precision values: 1.0, 0.99, 0.98, 0.95, 0.90
   - Even at 0.90 precision, still getting random failures (~30% failure rate)

2. **Renderer investigation** (Iterations 6-8)
   - Examined SwiftUIRenderer attributed string handling
   - Verified IR AttributedText conversion logic
   - Checked for async rendering issues

3. **Test setup modifications** (Iterations 9-12)
   - Tried different snapshot sizes
   - Added delays before snapshot capture
   - Simplified attributed string (still non-deterministic)

### Code Attempted
```swift
// Final failing version (iteration 12)
@MainActor
func testTextWithAttributedString() async throws {
    let attributedText = AttributedText(
        segments: [
            AttributedText.Segment(text: "Hello ", style: .regular),
            AttributedText.Segment(text: "World", style: .bold)
        ]
    )

    let node = RenderNode.text(TextNode(
        attributedContent: attributedText,
        padding: .zero
    ))

    let image = await RendererTestHelpers.renderSwiftUI(
        node,
        size: StandardSnapshotSizes.compact
    )

    // Even with 10% tolerance, still fails randomly
    assertSnapshot(
        of: image,
        as: .image(perceptualPrecision: 0.90),
        named: "text-attributed"
    )
}
```

### Analysis

**Root Cause Hypothesis**:
SwiftUI's Text view with AttributedString may have non-deterministic rendering behavior, possibly related to:
- Font loading timing
- Attributed string internal caching
- SwiftUI layout system flakiness

**Evidence**:
- Simple Text views (no attributes) are stable
- UIKit renderer with NSAttributedString is stable
- Only SwiftUI + AttributedString combination is flaky

### Recommended Next Steps

1. **Short term**: Skip this test, mark as known issue
2. **Alternative approach**: Test attributed string properties directly instead of visual rendering
3. **Research**: Check if swift-snapshot-testing has known issues with SwiftUI AttributedString
4. **Consider**: File bug report with Apple if this is SwiftUI framework issue

### Related Issues
- None yet

### Commits Reverted
- All changes related to this test were reverted (no commit)

---

## ButtonNodeSnapshotTests.testButtonWithGradientBackground

**Date Added**: 2024-01-27
**Renderer**: SwiftUI
**Status**: Gradient rendering inconsistent
**Priority**: Low

### Symptom
Buttons with gradient backgrounds render with slight color variations between test runs.

### What We Tried
(Document similar to above...)

### Analysis
(Document similar to above...)

---

## Statistics

- **Total Failing Tests**: 2
- **By Renderer**: SwiftUI (2), UIKit (0), HTML (0)
- **By Component**: TextNode (1), ButtonNode (1)
- **By Category**: AttributedString (1), Gradients (1)

---

## Review Schedule

Revisit these tests:
- After SwiftUI framework updates
- After swift-snapshot-testing library updates
- When implementing alternative testing approaches
- Monthly review to see if any can be unblocked
```

### Commit Message Template

Use this format for successful test commits:

```
Add snapshot test for [component] [scenario]

[Detailed description of what the test covers]

Changes:
- [Test file changes]
- [Snapshot files added]
- [Any renderer/SCALS fixes made]

Notes:
- [Tolerance decisions and why]
- [Any caveats or known limitations]
- [Related test coverage]

Co-Authored-By: Claude (us.anthropic.claude-sonnet-4-5-20250929-v1:0) <noreply@anthropic.com>
```

Example:
```
Add snapshot test for button with disabled state

Tests ButtonNode rendering in disabled state with proper styling:
- Reduced opacity
- Gray color scheme
- Non-interactive appearance

Changes:
- Added testButtonWithDisabledState to ButtonNodeSnapshotTests
- Snapshot: button-disabled.png (390x200)
- Fixed: UIKitRenderer wasn't applying disabled styling

Notes:
- Using 0.98 precision for minor anti-aliasing differences
- Disabled state opacity matches iOS system buttons (0.4)
- Verified across light and dark mode

Co-Authored-By: Claude (us.anthropic.claude-sonnet-4-5-20250929-v1:0) <noreply@anthropic.com>
```

---

## Contact and Support

For questions or issues with snapshot testing:
- Create an issue in the repository
- Add comments in test code to document problem areas or workarounds
- Use descriptive test method names to indicate known issues (e.g., `testButtonLayout_KnownIssue`)

---

## Quick Reference: Autonomous Workflow

### Starting a Phase

```bash
# Start Phase 2 (Core Components)
git checkout main
git checkout -b snapshot-tests/phase-2-components
echo "Starting Phase 2 autonomously..."

# The workflow now runs autonomously:
# 1. Write test
# 2. Record snapshot
# 3. Run test
# 4. If fail ‚Üí iterate (adjust tolerance or fix bug)
# 5. If pass ‚Üí commit and move to next test
# 6. If can't pass after 10 iterations ‚Üí document in FAILING_TESTS.md and move on
# 7. Repeat for all planned tests in phase
```

### No Human Interaction Required

The workflow makes all decisions autonomously:
- Tolerance adjustments (0.98, 0.95, 0.92, etc.)
- Bug fixes in renderers or SCALS
- Test reverts for failing tests
- Commits for passing tests
- Documentation of failing tests

### Monitoring Progress

```bash
# Check overall progress
cat SNAPSHOT_TEST_PROGRESS.md

# Check failing tests
cat FAILING_TESTS.md

# See recent commits
git log --oneline -20

# Watch progress in real-time
tail -f build.log  # or whatever log file is being used
```

### Completing a Phase

```bash
# Merge phase back to main
git checkout main
git merge snapshot-tests/phase-2-components
git tag snapshot-tests-phase-2-complete
git push origin main --tags

# Start next phase
git checkout -b snapshot-tests/phase-3-cross-renderer
# Continue autonomous execution...
```

### Emergency Rollback

```bash
# Revert entire phase
git reset --hard snapshot-tests-phase-1-complete

# Or revert to savepoint within phase
git reset --hard snapshot-tests-phase-2-textnode-complete

# Or cherry-pick only good commits
git cherry-pick <commit-hash>
```

### Key Files to Monitor

| File | Purpose |
|------|---------|
| `SNAPSHOT_TEST_PROGRESS.md` | Current status, completed tests, stats |
| `FAILING_TESTS.md` | Tests that couldn't be stabilized |
| `ScalsModulesTests/__Snapshots__/` | Snapshot images |
| `.git/refs/tags/` | Phase completion tags and savepoints |

### Decision Tree (Autonomous)

```
Test fails?
‚îú‚îÄ Tolerance issue? ‚Üí Increase by 0.01-0.02 ‚Üí Retry
‚îú‚îÄ Renderer bug? ‚Üí Fix renderer code ‚Üí Re-record ‚Üí Retry
‚îú‚îÄ SCALS bug? ‚Üí Fix SCALS code ‚Üí Re-record ‚Üí Retry
‚îú‚îÄ Test setup issue? ‚Üí Fix test ‚Üí Re-record ‚Üí Retry
‚îî‚îÄ Still failing after 10 iterations? ‚Üí Document in FAILING_TESTS.md ‚Üí Revert changes ‚Üí Next test
```

---

**Ready to start?** Run Phase 1 setup and let the autonomous workflow handle the rest!
